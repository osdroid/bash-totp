#!/usr/bin/env bash

declare -i TOTP_INTERVAL
declare -i TOTP_PERIOD

# Before we get the token, redirect stdout to stderr.
exec 3>&1 1>&2

TOTP_SECRET=${1?The secret was not supplied}
TOTP_INTERVAL=${2:-30}
TOTP_SECRET=${TOTP_SECRET^^}
TOTP_SECRET=$(tr -cd A-Z2-7= <<< "$TOTP_SECRET")

if [ "$TOTP_INTERVAL" -le 0 ]; then
    echo "The update interval must be a positive integer: $2"
    exit 1
fi
CURR_TIME=$(date +%s)
TOTP_PERIOD=$(( CURR_TIME / TOTP_INTERVAL ))
TOTP_REMAINING=$(( (TOTP_PERIOD + 1) * TOTP_INTERVAL - CURR_TIME ))

gen_digest() {
    local key=$1 period=$2
    printf "$(printf %016X "${period}" | sed 's/../\\x&/g')" |
	openssl dgst -sha1 -mac HMAC -macopt "hexkey:${key}" |
	cut -d\  -f2
}

gen_token() {
    local secret=$1 period=$2
    local key=$(echo "$secret" | base32 -d | hexdump -ve '/1 "%02X"')
    [ -z "$key" ] && exit 1
    # The digest is a 160-bit hexadecimal number string.
    local digest=$(gen_digest "${key}" "${period}")
    [ "${#digest}" -ne 40 ] && exit 2
    # Read the last 4 bits and convert it into an unsigned integer.
    local offset=$(( $(printf %d "0x${digest:39}") * 2 ))
    # Read a 32-bit positive integer and take at most six rightmost digits.
    local token=$(( (0x${digest:offset:8} & 0x7FFFFFFF) % 1000000 ))
    # Pad the token number with leading zeros if needed.
    printf '%06d\n' "${token}" >&3
}
echo ${TOTP_REMAINING}s...
gen_token "${TOTP_SECRET}" "${TOTP_PERIOD}"
